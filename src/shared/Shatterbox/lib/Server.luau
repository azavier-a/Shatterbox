--!strict
--!native
--!optimize 2
--!nolint LocalShadow
--#selene: allow(shadowing)
--#selene: allow(unused_variable)
--#selene: allow(multiple_statements)
--#selene: allow(parenthese_conditions)
-- File generated by Blink v0.17.4 (https://github.com/1Axen/Blink)
-- This file is not meant to be edited

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")

local BASE_EVENT_NAME = "BLINK"
local Invocations = 0

local SendSize = 64
local SendOffset = 0
local SendCursor = 0
local SendBuffer = buffer.create(64)
local SendInstances = {}

local RecieveCursor = 0
local RecieveBuffer = buffer.create(64)

local RecieveInstances = {}
local RecieveInstanceCursor = 0

local Null = newproxy()

type Entry = {
    value: any,
    next: Entry?
}

type Queue = {
    head: Entry?,
    tail: Entry?
}

type BufferSave = {
    Size: number, 
    Cursor: number, 
    Buffer: buffer, 
    Instances: {Instance}
}

local function Read(Bytes: number)
    local Offset = RecieveCursor
    RecieveCursor += Bytes
    return Offset
end

local function Save(): BufferSave
    return {
        Size = SendSize,
        Cursor = SendCursor,
        Buffer = SendBuffer,
        Instances = SendInstances
    }
end

local function Load(Save: BufferSave?)
    if Save then
        SendSize = Save.Size
        SendCursor = Save.Cursor
        SendOffset = Save.Cursor
        SendBuffer = Save.Buffer
        SendInstances = Save.Instances
        return
    end

    SendSize = 64
    SendCursor = 0
    SendOffset = 0
    SendBuffer = buffer.create(64)
    SendInstances = {}
end

local function Invoke()
    if Invocations == 255 then
        Invocations = 0
    end

    local Invocation = Invocations
    Invocations += 1
    return Invocation
end

local function Allocate(Bytes: number)
    local InUse = (SendCursor + Bytes)
    if InUse > SendSize then
        --> Avoid resizing the buffer for every write
        while InUse > SendSize do
            SendSize *= 1.5
        end

        local Buffer = buffer.create(SendSize)
        buffer.copy(Buffer, 0, SendBuffer, 0, SendCursor)
        SendBuffer = Buffer
    end

    SendOffset = SendCursor
    SendCursor += Bytes
    
    return SendOffset
end

local function CreateQueue(): Queue
    return {
        head = nil,
        tail = nil
    }
end

local function Pop(queue: Queue): any
    local head = queue.head
    if head == nil then
        return
    end

    queue.head = head.next
    return head.value
end

local function Push(queue: Queue, value: any)
    local entry: Entry = {
        value = value,
        next = nil
    }

    if queue.tail ~= nil then
        queue.tail.next = entry
    end

    queue.tail = entry

    if queue.head == nil then
        queue.head = entry
    end
end

local Calls = table.create(256)

local Events: any = {
    Reliable = table.create(256),
    Unreliable = table.create(256)
}

local Queue: any = {
    Reliable = table.create(256),
    Unreliable = table.create(256)
}

Queue.Reliable[3] = table.create(256)
Queue.Reliable[4] = table.create(256)
export type PartType = ("Ball" | "Block" | "Cylinder" | "Wedge" | "CornerWedge")
export type Material = ("Plastic" | "SmoothPlastic" | "Neon" | "Wood" | "WoodPlanks" | "Marble" | "Slate" | "Concrete" | "Granite" | "Brick" | "Pebble" | "Cobblestone" | "Rock" | "Sandstone" | "Basalt" | "CrackedLava" | "Limestone" | "Pavement" | "CorrodedMetal" | "DiamondPlate" | "Foil" | "Metal" | "Grass" | "LeafyGrass" | "Sand" | "Fabric" | "Snow" | "Mud" | "Ground" | "Asphalt" | "Salt" | "Ice" | "Glacier" | "Glass" | "ForceField" | "Air" | "Water" | "Cardboard" | "Carpet" | "CeramicTiles" | "ClayRoofTiles" | "RoofShingles" | "Leather" | "Plaster" | "Rubber")
export type RaycastFilterType = ("Include" | "Exclude")
export type PartInstance = { CFrame: CFrame, Size: Vector3, Material: ("Plastic" | "SmoothPlastic" | "Neon" | "Wood" | "WoodPlanks" | "Marble" | "Slate" | "Concrete" | "Granite" | "Brick" | "Pebble" | "Cobblestone" | "Rock" | "Sandstone" | "Basalt" | "CrackedLava" | "Limestone" | "Pavement" | "CorrodedMetal" | "DiamondPlate" | "Foil" | "Metal" | "Grass" | "LeafyGrass" | "Sand" | "Fabric" | "Snow" | "Mud" | "Ground" | "Asphalt" | "Salt" | "Ice" | "Glacier" | "Glass" | "ForceField" | "Air" | "Water" | "Cardboard" | "Carpet" | "CeramicTiles" | "ClayRoofTiles" | "RoofShingles" | "Leather" | "Plaster" | "Rubber"), Transparency: number }
export type DestructionParamsType = { Shape: ("Ball" | "Block" | "Cylinder" | "Wedge" | "CornerWedge"), CFrame: CFrame, Size: Vector3, OverlapFilterType: ("Include" | "Exclude")?, OverlapFilterDescendants: { Instance }?, GridSize: number?, CleanupDelay: number?, SkipEncapsulatedVoxels: boolean?, finalOpTick: number?, ID: string, OnVoxelDestruct: string?, DestructParameters: { any } }
export type VoxStatesArr = {[string]: CFrame}
local function WriteEVENT_SignalDestruction(Value: { Shape: ("Ball" | "Block" | "Cylinder" | "Wedge" | "CornerWedge"), CFrame: CFrame, Size: Vector3, OverlapFilterType: ("Include" | "Exclude")?, OverlapFilterDescendants: { Instance }?, GridSize: number?, CleanupDelay: number?, SkipEncapsulatedVoxels: boolean?, finalOpTick: number?, ID: string, OnVoxelDestruct: string?, DestructParameters: { any } }): ()
	-- Allocate BLOCK: 49 bytes
	local BLOCK_START = Allocate(49)
	buffer.writeu8(SendBuffer, BLOCK_START + 0, 0)
	if Value.Shape == "Ball" then
		buffer.writeu8(SendBuffer, BLOCK_START + 1, 0)
	elseif Value.Shape == "Block" then
		buffer.writeu8(SendBuffer, BLOCK_START + 1, 1)
	elseif Value.Shape == "Cylinder" then
		buffer.writeu8(SendBuffer, BLOCK_START + 1, 2)
	elseif Value.Shape == "Wedge" then
		buffer.writeu8(SendBuffer, BLOCK_START + 1, 3)
	elseif Value.Shape == "CornerWedge" then
		buffer.writeu8(SendBuffer, BLOCK_START + 1, 4)
	else
		error(`Unexpected enum: {Value.Shape}, expected one of "Ball" or "Block" or "Cylinder" or "Wedge" or "CornerWedge".`)
	end
	local Vector = Value.CFrame.Position
	buffer.writef32(SendBuffer, BLOCK_START + 2, Vector.X)
	buffer.writef32(SendBuffer, BLOCK_START + 6, Vector.Y)
	buffer.writef32(SendBuffer, BLOCK_START + 10, Vector.Z)
	local rX, rY, rZ = Value.CFrame:ToOrientation()
	buffer.writef32(SendBuffer, BLOCK_START + 14, rX)
	buffer.writef32(SendBuffer, BLOCK_START + 18, rY)
	buffer.writef32(SendBuffer, BLOCK_START + 22, rZ)
	local Vector = Value.Size
	buffer.writef32(SendBuffer, BLOCK_START + 26, Vector.X)
	buffer.writef32(SendBuffer, BLOCK_START + 30, Vector.Y)
	buffer.writef32(SendBuffer, BLOCK_START + 34, Vector.Z)
	buffer.writeu8(SendBuffer, BLOCK_START + 38, Value.OverlapFilterType ~= nil and 1 or 0)
	if Value.OverlapFilterType ~= nil then
		-- Allocate BLOCK: 1 bytes
		local BLOCK_START = Allocate(1)
		if Value.OverlapFilterType == "Include" then
			buffer.writeu8(SendBuffer, BLOCK_START + 0, 0)
		elseif Value.OverlapFilterType == "Exclude" then
			buffer.writeu8(SendBuffer, BLOCK_START + 0, 1)
		else
			error(`Unexpected enum: {Value.OverlapFilterType}, expected one of "Include" or "Exclude".`)
		end
	end
	buffer.writeu8(SendBuffer, BLOCK_START + 39, Value.OverlapFilterDescendants ~= nil and 1 or 0)
	if Value.OverlapFilterDescendants ~= nil then
		-- Allocate BLOCK: 2 bytes
		local BLOCK_START = Allocate(2)
		-- START ARRAY
		buffer.writeu16(SendBuffer, BLOCK_START + 0, #Value.OverlapFilterDescendants)
		for Index = 1, #Value.OverlapFilterDescendants do
			local Item_2 = Value.OverlapFilterDescendants[Index]
			table.insert(SendInstances, Item_2 or Null)
		end
		-- END ARRAY
	end
	buffer.writeu8(SendBuffer, BLOCK_START + 40, Value.GridSize ~= nil and 1 or 0)
	if Value.GridSize ~= nil then
		-- Allocate BLOCK: 4 bytes
		local BLOCK_START = Allocate(4)
		buffer.writef32(SendBuffer, BLOCK_START + 0, Value.GridSize)
	end
	buffer.writeu8(SendBuffer, BLOCK_START + 41, Value.CleanupDelay ~= nil and 1 or 0)
	if Value.CleanupDelay ~= nil then
		-- Allocate BLOCK: 4 bytes
		local BLOCK_START = Allocate(4)
		buffer.writef32(SendBuffer, BLOCK_START + 0, Value.CleanupDelay)
	end
	buffer.writeu8(SendBuffer, BLOCK_START + 42, Value.SkipEncapsulatedVoxels ~= nil and 1 or 0)
	if Value.SkipEncapsulatedVoxels ~= nil then
		-- Allocate BLOCK: 1 bytes
		local BLOCK_START = Allocate(1)
		buffer.writeu8(SendBuffer, BLOCK_START + 0, Value.SkipEncapsulatedVoxels and 1 or 0)
	end
	buffer.writeu8(SendBuffer, BLOCK_START + 43, Value.finalOpTick ~= nil and 1 or 0)
	if Value.finalOpTick ~= nil then
		-- Allocate BLOCK: 4 bytes
		local BLOCK_START = Allocate(4)
		buffer.writeu32(SendBuffer, BLOCK_START + 0, Value.finalOpTick)
	end
	local Length = #Value.ID
	buffer.writeu16(SendBuffer, BLOCK_START + 44, Length)
	Allocate(Length)
	buffer.writestring(SendBuffer, SendOffset, Value.ID, Length)
	buffer.writeu8(SendBuffer, BLOCK_START + 46, Value.OnVoxelDestruct ~= nil and 1 or 0)
	if Value.OnVoxelDestruct ~= nil then
		-- Allocate BLOCK: 2 bytes
		local BLOCK_START = Allocate(2)
		local Length = #Value.OnVoxelDestruct
		buffer.writeu16(SendBuffer, BLOCK_START + 0, Length)
		Allocate(Length)
		buffer.writestring(SendBuffer, SendOffset, Value.OnVoxelDestruct, Length)
	end
	-- START ARRAY
	buffer.writeu16(SendBuffer, BLOCK_START + 47, #Value.DestructParameters)
	for Index = 1, #Value.DestructParameters do
		local Item_1 = Value.DestructParameters[Index]
		table.insert(SendInstances, if Item_1 == nil then Null else Item_1)
	end
	-- END ARRAY
end

local function WriteEVENT_SignalUndo(Value: string): ()
	-- Allocate BLOCK: 3 bytes
	local BLOCK_START = Allocate(3)
	buffer.writeu8(SendBuffer, BLOCK_START + 0, 1)
	local Length = #Value
	buffer.writeu16(SendBuffer, BLOCK_START + 1, Length)
	Allocate(Length)
	buffer.writestring(SendBuffer, SendOffset, Value, Length)
end

local function WriteEVENT_SignalClearQueue(Value: nil): ()
	-- Allocate BLOCK: 1 bytes
	local BLOCK_START = Allocate(1)
	buffer.writeu8(SendBuffer, BLOCK_START + 0, 2)
end

local function ReadEVENT_MapReplicationCompleted(): (string)
	-- Read BLOCK: 2 bytes
	local BLOCK_START = Read(2)
	local Length = buffer.readu16(RecieveBuffer, BLOCK_START + 0)
	local Value = buffer.readstring(RecieveBuffer, Read(Length), Length)
	return Value
end

local function ReadEVENT_UndoReplicationCompleted(): (nil)
	return nil
end

local function WriteEVENT_CreatePuppet(Value1: string, Value2: { CFrame: CFrame, Size: Vector3, Material: ("Plastic" | "SmoothPlastic" | "Neon" | "Wood" | "WoodPlanks" | "Marble" | "Slate" | "Concrete" | "Granite" | "Brick" | "Pebble" | "Cobblestone" | "Rock" | "Sandstone" | "Basalt" | "CrackedLava" | "Limestone" | "Pavement" | "CorrodedMetal" | "DiamondPlate" | "Foil" | "Metal" | "Grass" | "LeafyGrass" | "Sand" | "Fabric" | "Snow" | "Mud" | "Ground" | "Asphalt" | "Salt" | "Ice" | "Glacier" | "Glass" | "ForceField" | "Air" | "Water" | "Cardboard" | "Carpet" | "CeramicTiles" | "ClayRoofTiles" | "RoofShingles" | "Leather" | "Plaster" | "Rubber"), Transparency: number }): ()
	-- Allocate BLOCK: 42 bytes
	local BLOCK_START = Allocate(42)
	buffer.writeu8(SendBuffer, BLOCK_START + 0, 5)
	local Length = #Value1
	buffer.writeu16(SendBuffer, BLOCK_START + 1, Length)
	Allocate(Length)
	buffer.writestring(SendBuffer, SendOffset, Value1, Length)
	local Vector = Value2.CFrame.Position
	buffer.writef32(SendBuffer, BLOCK_START + 3, Vector.X)
	buffer.writef32(SendBuffer, BLOCK_START + 7, Vector.Y)
	buffer.writef32(SendBuffer, BLOCK_START + 11, Vector.Z)
	local rX, rY, rZ = Value2.CFrame:ToOrientation()
	buffer.writef32(SendBuffer, BLOCK_START + 15, rX)
	buffer.writef32(SendBuffer, BLOCK_START + 19, rY)
	buffer.writef32(SendBuffer, BLOCK_START + 23, rZ)
	local Vector = Value2.Size
	buffer.writef32(SendBuffer, BLOCK_START + 27, Vector.X)
	buffer.writef32(SendBuffer, BLOCK_START + 31, Vector.Y)
	buffer.writef32(SendBuffer, BLOCK_START + 35, Vector.Z)
	if Value2.Material == "Plastic" then
		buffer.writeu8(SendBuffer, BLOCK_START + 39, 0)
	elseif Value2.Material == "SmoothPlastic" then
		buffer.writeu8(SendBuffer, BLOCK_START + 39, 1)
	elseif Value2.Material == "Neon" then
		buffer.writeu8(SendBuffer, BLOCK_START + 39, 2)
	elseif Value2.Material == "Wood" then
		buffer.writeu8(SendBuffer, BLOCK_START + 39, 3)
	elseif Value2.Material == "WoodPlanks" then
		buffer.writeu8(SendBuffer, BLOCK_START + 39, 4)
	elseif Value2.Material == "Marble" then
		buffer.writeu8(SendBuffer, BLOCK_START + 39, 5)
	elseif Value2.Material == "Slate" then
		buffer.writeu8(SendBuffer, BLOCK_START + 39, 6)
	elseif Value2.Material == "Concrete" then
		buffer.writeu8(SendBuffer, BLOCK_START + 39, 7)
	elseif Value2.Material == "Granite" then
		buffer.writeu8(SendBuffer, BLOCK_START + 39, 8)
	elseif Value2.Material == "Brick" then
		buffer.writeu8(SendBuffer, BLOCK_START + 39, 9)
	elseif Value2.Material == "Pebble" then
		buffer.writeu8(SendBuffer, BLOCK_START + 39, 10)
	elseif Value2.Material == "Cobblestone" then
		buffer.writeu8(SendBuffer, BLOCK_START + 39, 11)
	elseif Value2.Material == "Rock" then
		buffer.writeu8(SendBuffer, BLOCK_START + 39, 12)
	elseif Value2.Material == "Sandstone" then
		buffer.writeu8(SendBuffer, BLOCK_START + 39, 13)
	elseif Value2.Material == "Basalt" then
		buffer.writeu8(SendBuffer, BLOCK_START + 39, 14)
	elseif Value2.Material == "CrackedLava" then
		buffer.writeu8(SendBuffer, BLOCK_START + 39, 15)
	elseif Value2.Material == "Limestone" then
		buffer.writeu8(SendBuffer, BLOCK_START + 39, 16)
	elseif Value2.Material == "Pavement" then
		buffer.writeu8(SendBuffer, BLOCK_START + 39, 17)
	elseif Value2.Material == "CorrodedMetal" then
		buffer.writeu8(SendBuffer, BLOCK_START + 39, 18)
	elseif Value2.Material == "DiamondPlate" then
		buffer.writeu8(SendBuffer, BLOCK_START + 39, 19)
	elseif Value2.Material == "Foil" then
		buffer.writeu8(SendBuffer, BLOCK_START + 39, 20)
	elseif Value2.Material == "Metal" then
		buffer.writeu8(SendBuffer, BLOCK_START + 39, 21)
	elseif Value2.Material == "Grass" then
		buffer.writeu8(SendBuffer, BLOCK_START + 39, 22)
	elseif Value2.Material == "LeafyGrass" then
		buffer.writeu8(SendBuffer, BLOCK_START + 39, 23)
	elseif Value2.Material == "Sand" then
		buffer.writeu8(SendBuffer, BLOCK_START + 39, 24)
	elseif Value2.Material == "Fabric" then
		buffer.writeu8(SendBuffer, BLOCK_START + 39, 25)
	elseif Value2.Material == "Snow" then
		buffer.writeu8(SendBuffer, BLOCK_START + 39, 26)
	elseif Value2.Material == "Mud" then
		buffer.writeu8(SendBuffer, BLOCK_START + 39, 27)
	elseif Value2.Material == "Ground" then
		buffer.writeu8(SendBuffer, BLOCK_START + 39, 28)
	elseif Value2.Material == "Asphalt" then
		buffer.writeu8(SendBuffer, BLOCK_START + 39, 29)
	elseif Value2.Material == "Salt" then
		buffer.writeu8(SendBuffer, BLOCK_START + 39, 30)
	elseif Value2.Material == "Ice" then
		buffer.writeu8(SendBuffer, BLOCK_START + 39, 31)
	elseif Value2.Material == "Glacier" then
		buffer.writeu8(SendBuffer, BLOCK_START + 39, 32)
	elseif Value2.Material == "Glass" then
		buffer.writeu8(SendBuffer, BLOCK_START + 39, 33)
	elseif Value2.Material == "ForceField" then
		buffer.writeu8(SendBuffer, BLOCK_START + 39, 34)
	elseif Value2.Material == "Air" then
		buffer.writeu8(SendBuffer, BLOCK_START + 39, 35)
	elseif Value2.Material == "Water" then
		buffer.writeu8(SendBuffer, BLOCK_START + 39, 36)
	elseif Value2.Material == "Cardboard" then
		buffer.writeu8(SendBuffer, BLOCK_START + 39, 37)
	elseif Value2.Material == "Carpet" then
		buffer.writeu8(SendBuffer, BLOCK_START + 39, 38)
	elseif Value2.Material == "CeramicTiles" then
		buffer.writeu8(SendBuffer, BLOCK_START + 39, 39)
	elseif Value2.Material == "ClayRoofTiles" then
		buffer.writeu8(SendBuffer, BLOCK_START + 39, 40)
	elseif Value2.Material == "RoofShingles" then
		buffer.writeu8(SendBuffer, BLOCK_START + 39, 41)
	elseif Value2.Material == "Leather" then
		buffer.writeu8(SendBuffer, BLOCK_START + 39, 42)
	elseif Value2.Material == "Plaster" then
		buffer.writeu8(SendBuffer, BLOCK_START + 39, 43)
	elseif Value2.Material == "Rubber" then
		buffer.writeu8(SendBuffer, BLOCK_START + 39, 44)
	else
		error(`Unexpected enum: {Value2.Material}, expected one of "Plastic" or "SmoothPlastic" or "Neon" or "Wood" or "WoodPlanks" or "Marble" or "Slate" or "Concrete" or "Granite" or "Brick" or "Pebble" or "Cobblestone" or "Rock" or "Sandstone" or "Basalt" or "CrackedLava" or "Limestone" or "Pavement" or "CorrodedMetal" or "DiamondPlate" or "Foil" or "Metal" or "Grass" or "LeafyGrass" or "Sand" or "Fabric" or "Snow" or "Mud" or "Ground" or "Asphalt" or "Salt" or "Ice" or "Glacier" or "Glass" or "ForceField" or "Air" or "Water" or "Cardboard" or "Carpet" or "CeramicTiles" or "ClayRoofTiles" or "RoofShingles" or "Leather" or "Plaster" or "Rubber".`)
	end
	if Value2.Transparency > 65504 then
		buffer.writeu16(SendBuffer, BLOCK_START + 40, 0b0_11111_0000000000)
	elseif Value2.Transparency < -65504 then
		buffer.writeu16(SendBuffer, BLOCK_START + 40, 0b1_11111_0000000000)
	elseif Value2.Transparency ~= Value2.Transparency then
		buffer.writeu16(SendBuffer, BLOCK_START + 40, 0b1_11111_0000000001)
	elseif Value2.Transparency == 0 then
		buffer.writeu16(SendBuffer, BLOCK_START + 40, 0)
	else
		local float = Value2.Transparency
		local Abosulte = math.abs(float)
		local Interval = math.ldexp(1, math.floor(math.log(Abosulte, 2)) - 10)
		local RoundedValue = (Abosulte // Interval) * Interval
		local Fraction, Exponent = math.frexp(RoundedValue)
		Exponent += 14
		local Mantissa = math.round(if Exponent <= 0
			then Fraction * 0x400 / math.ldexp(1, math.abs(Exponent))
			else Fraction * 0x800) % 0x400
		local Result = Mantissa
			+ math.max(Exponent, 0) * 0x400
			+ if float < 0 then 0x8000 else 0
		buffer.writeu16(SendBuffer, BLOCK_START + 40, Result)
	end
end

local function WriteEVENT_ReplicatePuppetStates(Value: {[string]: CFrame}): ()
	-- Allocate BLOCK: 3 bytes
	local BLOCK_START = Allocate(3)
	buffer.writeu8(SendBuffer, BLOCK_START + 0, 6)
	local Elements_1 = 0
	for Key_1, Element_1 in Value do
		Elements_1 += 1
		local Length = #Key_1
		local OFFSET_0 = Allocate(2)
		buffer.writeu16(SendBuffer, OFFSET_0, Length)
		Allocate(Length)
		buffer.writestring(SendBuffer, SendOffset, Key_1, Length)
		local Vector = Element_1.Position
		local OFFSET_1 = Allocate(4)
		buffer.writef32(SendBuffer, OFFSET_1, Vector.X)
		local OFFSET_2 = Allocate(4)
		buffer.writef32(SendBuffer, OFFSET_2, Vector.Y)
		local OFFSET_3 = Allocate(4)
		buffer.writef32(SendBuffer, OFFSET_3, Vector.Z)
		local rX, rY, rZ = Element_1:ToOrientation()
		local OFFSET_4 = Allocate(4)
		buffer.writef32(SendBuffer, OFFSET_4, rX)
		local OFFSET_5 = Allocate(4)
		buffer.writef32(SendBuffer, OFFSET_5, rY)
		local OFFSET_6 = Allocate(4)
		buffer.writef32(SendBuffer, OFFSET_6, rZ)
	end
	buffer.writeu16(SendBuffer, BLOCK_START + 1, Elements_1)
end

if not RunService:IsRunning() then
	local NOOP = function() end
	local Returns = table.freeze({
	SignalDestruction = {
		Fire = NOOP,
		FireAll = NOOP,
		FireList = NOOP,
		FireExcept = NOOP
	},
	SignalUndo = {
		Fire = NOOP,
		FireAll = NOOP,
		FireList = NOOP,
		FireExcept = NOOP
	},
	SignalClearQueue = {
		Fire = NOOP,
		FireAll = NOOP,
		FireList = NOOP,
		FireExcept = NOOP
	},
	MapReplicationCompleted = {
		On = NOOP
	},
	UndoReplicationCompleted = {
		On = NOOP
	},
	CreatePuppet = {
		Fire = NOOP,
		FireAll = NOOP,
		FireList = NOOP,
		FireExcept = NOOP
	},
	ReplicatePuppetStates = {
		Fire = NOOP,
		FireAll = NOOP,
		FireList = NOOP,
		FireExcept = NOOP
	},
	})
	return Returns :: BLINK_EVENTS_SYMBOL
end

if not RunService:IsServer() then
    error("Server network module can only be required from the server.")
end

local Reliable: RemoteEvent = ReplicatedStorage:FindFirstChild(BASE_EVENT_NAME .. "_RELIABLE_REMOTE") :: RemoteEvent
if not Reliable then
    local RemoteEvent = Instance.new("RemoteEvent")
    RemoteEvent.Name = BASE_EVENT_NAME .. "_RELIABLE_REMOTE"
    RemoteEvent.Parent = ReplicatedStorage
    Reliable = RemoteEvent
end

local Unreliable: UnreliableRemoteEvent = ReplicatedStorage:FindFirstChild(BASE_EVENT_NAME .. "_UNRELIABLE_REMOTE") :: UnreliableRemoteEvent
if not Unreliable then
    local UnreliableRemoteEvent = Instance.new("UnreliableRemoteEvent")
    UnreliableRemoteEvent.Name = BASE_EVENT_NAME .. "_UNRELIABLE_REMOTE"
    UnreliableRemoteEvent.Parent = ReplicatedStorage
    Unreliable = UnreliableRemoteEvent
end

local PlayersMap: {[Player]: BufferSave} = {}

Players.PlayerRemoving:Connect(function(Player)
    PlayersMap[Player] = nil
end)

local function StepReplication()
    for Player, Send in PlayersMap do
        if Send.Cursor <= 0 then
            continue
        end

        local Buffer = buffer.create(Send.Cursor)
        buffer.copy(Buffer, 0, Send.Buffer, 0, Send.Cursor)
        Reliable:FireClient(Player, Buffer, Send.Instances)

        Send.Size = 64
        Send.Cursor = 0
        Send.Buffer = buffer.create(64)
        table.clear(Send.Instances)
    end
end
RunService.Heartbeat:Connect(StepReplication)
Reliable.OnServerEvent:Connect(function(Player: Player, Buffer: buffer, Instances: {Instance})
	RecieveCursor = 0
	RecieveBuffer = Buffer
	RecieveInstances = Instances
	RecieveInstanceCursor = 0
	local Size = buffer.len(RecieveBuffer)
	while (RecieveCursor < Size) do
		-- Read BLOCK: 1 bytes
		local BLOCK_START = Read(1)
		local Index = buffer.readu8(RecieveBuffer, BLOCK_START + 0)
		if Index == 3 then
			local Value: string = ReadEVENT_MapReplicationCompleted()
			if Events.Reliable[3] ~= nil then
				task.spawn(Events.Reliable[3], Player, Value)
			else
				if #Queue.Reliable[3] > 256 then
					warn("[Blink]: Event queue of \"MapReplicationCompleted\" exceeded 256, did you forget to implement a listener?")
				end
				table.insert(Queue.Reliable[3], {Player, Value} :: {any})
			end
		elseif Index == 4 then
			local Value: nil = ReadEVENT_UndoReplicationCompleted()
			if Events.Reliable[4] ~= nil then
				task.spawn(Events.Reliable[4], Player, Value)
			else
				if #Queue.Reliable[4] > 256 then
					warn("[Blink]: Event queue of \"UndoReplicationCompleted\" exceeded 256, did you forget to implement a listener?")
				end
				table.insert(Queue.Reliable[4], {Player, Value} :: {any})
			end
		end
	end
end)
Unreliable.OnServerEvent:Connect(function(Player: Player, Buffer: buffer, Instances: {Instance})
	RecieveCursor = 0
	RecieveBuffer = Buffer
	RecieveInstances = Instances
	RecieveInstanceCursor = 0
	local Size = buffer.len(RecieveBuffer)
	while (RecieveCursor < Size) do
		-- Read BLOCK: 1 bytes
		local BLOCK_START = Read(1)
		local Index = buffer.readu8(RecieveBuffer, BLOCK_START + 0)
	end
end)


local Returns = table.freeze({
	StepReplication = StepReplication,

	SignalDestruction = {
		Fire = function(Player: Player, Value: { Shape: ("Ball" | "Block" | "Cylinder" | "Wedge" | "CornerWedge"), CFrame: CFrame, Size: Vector3, OverlapFilterType: ("Include" | "Exclude")?, OverlapFilterDescendants: { Instance }?, GridSize: number?, CleanupDelay: number?, SkipEncapsulatedVoxels: boolean?, finalOpTick: number?, ID: string, OnVoxelDestruct: string?, DestructParameters: { any } }): ()
			Load(PlayersMap[Player])
			WriteEVENT_SignalDestruction(Value)
			PlayersMap[Player] = Save()
		end,
		FireAll = function(Value: { Shape: ("Ball" | "Block" | "Cylinder" | "Wedge" | "CornerWedge"), CFrame: CFrame, Size: Vector3, OverlapFilterType: ("Include" | "Exclude")?, OverlapFilterDescendants: { Instance }?, GridSize: number?, CleanupDelay: number?, SkipEncapsulatedVoxels: boolean?, finalOpTick: number?, ID: string, OnVoxelDestruct: string?, DestructParameters: { any } }): ()
			Load()
			WriteEVENT_SignalDestruction(Value)
			local Buffer, Size, Instances = SendBuffer, SendCursor, SendInstances
			for _, Player in Players:GetPlayers() do
				Load(PlayersMap[Player])
				local Position = Allocate(Size)
				buffer.copy(SendBuffer, Position, Buffer, 0, Size)
				table.move(Instances, 1, #Instances, #SendInstances + 1, SendInstances)
				PlayersMap[Player] = Save()
			end
		end,
		FireList = function(List: {Player}, Value: { Shape: ("Ball" | "Block" | "Cylinder" | "Wedge" | "CornerWedge"), CFrame: CFrame, Size: Vector3, OverlapFilterType: ("Include" | "Exclude")?, OverlapFilterDescendants: { Instance }?, GridSize: number?, CleanupDelay: number?, SkipEncapsulatedVoxels: boolean?, finalOpTick: number?, ID: string, OnVoxelDestruct: string?, DestructParameters: { any } }): ()
			Load()
			WriteEVENT_SignalDestruction(Value)
			local Buffer, Size, Instances = SendBuffer, SendCursor, SendInstances
			for _, Player in List do
				Load(PlayersMap[Player])
				local Position = Allocate(Size)
				buffer.copy(SendBuffer, Position, Buffer, 0, Size)
				table.move(Instances, 1, #Instances, #SendInstances + 1, SendInstances)
				PlayersMap[Player] = Save()
			end
		end,
		FireExcept = function(Except: Player, Value: { Shape: ("Ball" | "Block" | "Cylinder" | "Wedge" | "CornerWedge"), CFrame: CFrame, Size: Vector3, OverlapFilterType: ("Include" | "Exclude")?, OverlapFilterDescendants: { Instance }?, GridSize: number?, CleanupDelay: number?, SkipEncapsulatedVoxels: boolean?, finalOpTick: number?, ID: string, OnVoxelDestruct: string?, DestructParameters: { any } }): ()
			Load()
			WriteEVENT_SignalDestruction(Value)
			local Buffer, Size, Instances = SendBuffer, SendCursor, SendInstances
			for _, Player in Players:GetPlayers() do
				if Player == Except then
					continue
				end
				Load(PlayersMap[Player])
				local Position = Allocate(Size)
				buffer.copy(SendBuffer, Position, Buffer, 0, Size)
				table.move(Instances, 1, #Instances, #SendInstances + 1, SendInstances)
				PlayersMap[Player] = Save()
			end
		end,
	},
	SignalUndo = {
		Fire = function(Player: Player, Value: string): ()
			Load(PlayersMap[Player])
			WriteEVENT_SignalUndo(Value)
			PlayersMap[Player] = Save()
		end,
		FireAll = function(Value: string): ()
			Load()
			WriteEVENT_SignalUndo(Value)
			local Buffer, Size, Instances = SendBuffer, SendCursor, SendInstances
			for _, Player in Players:GetPlayers() do
				Load(PlayersMap[Player])
				local Position = Allocate(Size)
				buffer.copy(SendBuffer, Position, Buffer, 0, Size)
				table.move(Instances, 1, #Instances, #SendInstances + 1, SendInstances)
				PlayersMap[Player] = Save()
			end
		end,
		FireList = function(List: {Player}, Value: string): ()
			Load()
			WriteEVENT_SignalUndo(Value)
			local Buffer, Size, Instances = SendBuffer, SendCursor, SendInstances
			for _, Player in List do
				Load(PlayersMap[Player])
				local Position = Allocate(Size)
				buffer.copy(SendBuffer, Position, Buffer, 0, Size)
				table.move(Instances, 1, #Instances, #SendInstances + 1, SendInstances)
				PlayersMap[Player] = Save()
			end
		end,
		FireExcept = function(Except: Player, Value: string): ()
			Load()
			WriteEVENT_SignalUndo(Value)
			local Buffer, Size, Instances = SendBuffer, SendCursor, SendInstances
			for _, Player in Players:GetPlayers() do
				if Player == Except then
					continue
				end
				Load(PlayersMap[Player])
				local Position = Allocate(Size)
				buffer.copy(SendBuffer, Position, Buffer, 0, Size)
				table.move(Instances, 1, #Instances, #SendInstances + 1, SendInstances)
				PlayersMap[Player] = Save()
			end
		end,
	},
	SignalClearQueue = {
		Fire = function(Player: Player, Value: nil): ()
			Load(PlayersMap[Player])
			WriteEVENT_SignalClearQueue(Value)
			PlayersMap[Player] = Save()
		end,
		FireAll = function(Value: nil): ()
			Load()
			WriteEVENT_SignalClearQueue(Value)
			local Buffer, Size, Instances = SendBuffer, SendCursor, SendInstances
			for _, Player in Players:GetPlayers() do
				Load(PlayersMap[Player])
				local Position = Allocate(Size)
				buffer.copy(SendBuffer, Position, Buffer, 0, Size)
				table.move(Instances, 1, #Instances, #SendInstances + 1, SendInstances)
				PlayersMap[Player] = Save()
			end
		end,
		FireList = function(List: {Player}, Value: nil): ()
			Load()
			WriteEVENT_SignalClearQueue(Value)
			local Buffer, Size, Instances = SendBuffer, SendCursor, SendInstances
			for _, Player in List do
				Load(PlayersMap[Player])
				local Position = Allocate(Size)
				buffer.copy(SendBuffer, Position, Buffer, 0, Size)
				table.move(Instances, 1, #Instances, #SendInstances + 1, SendInstances)
				PlayersMap[Player] = Save()
			end
		end,
		FireExcept = function(Except: Player, Value: nil): ()
			Load()
			WriteEVENT_SignalClearQueue(Value)
			local Buffer, Size, Instances = SendBuffer, SendCursor, SendInstances
			for _, Player in Players:GetPlayers() do
				if Player == Except then
					continue
				end
				Load(PlayersMap[Player])
				local Position = Allocate(Size)
				buffer.copy(SendBuffer, Position, Buffer, 0, Size)
				table.move(Instances, 1, #Instances, #SendInstances + 1, SendInstances)
				PlayersMap[Player] = Save()
			end
		end,
	},
	MapReplicationCompleted = {
		On = function(Listener: (Player: Player, Value: string) -> ()): () -> ()
			Events.Reliable[3] = Listener
			for Index, Arguments in Queue.Reliable[3] do
				task.spawn(Listener, table.unpack(Arguments))
			end
			Queue.Reliable[3] = {}
			return function (): ()
				if Events.Reliable[3] == Listener then
					Events.Reliable[3] = nil
				end
			end
		end
	},
	UndoReplicationCompleted = {
		On = function(Listener: (Player: Player, Value: nil) -> ()): () -> ()
			Events.Reliable[4] = Listener
			for Index, Arguments in Queue.Reliable[4] do
				task.spawn(Listener, table.unpack(Arguments))
			end
			Queue.Reliable[4] = {}
			return function (): ()
				if Events.Reliable[4] == Listener then
					Events.Reliable[4] = nil
				end
			end
		end
	},
	CreatePuppet = {
		Fire = function(Player: Player, Value1: string, Value2: { CFrame: CFrame, Size: Vector3, Material: ("Plastic" | "SmoothPlastic" | "Neon" | "Wood" | "WoodPlanks" | "Marble" | "Slate" | "Concrete" | "Granite" | "Brick" | "Pebble" | "Cobblestone" | "Rock" | "Sandstone" | "Basalt" | "CrackedLava" | "Limestone" | "Pavement" | "CorrodedMetal" | "DiamondPlate" | "Foil" | "Metal" | "Grass" | "LeafyGrass" | "Sand" | "Fabric" | "Snow" | "Mud" | "Ground" | "Asphalt" | "Salt" | "Ice" | "Glacier" | "Glass" | "ForceField" | "Air" | "Water" | "Cardboard" | "Carpet" | "CeramicTiles" | "ClayRoofTiles" | "RoofShingles" | "Leather" | "Plaster" | "Rubber"), Transparency: number }): ()
			Load(PlayersMap[Player])
			WriteEVENT_CreatePuppet(Value1, Value2)
			PlayersMap[Player] = Save()
		end,
		FireAll = function(Value1: string, Value2: { CFrame: CFrame, Size: Vector3, Material: ("Plastic" | "SmoothPlastic" | "Neon" | "Wood" | "WoodPlanks" | "Marble" | "Slate" | "Concrete" | "Granite" | "Brick" | "Pebble" | "Cobblestone" | "Rock" | "Sandstone" | "Basalt" | "CrackedLava" | "Limestone" | "Pavement" | "CorrodedMetal" | "DiamondPlate" | "Foil" | "Metal" | "Grass" | "LeafyGrass" | "Sand" | "Fabric" | "Snow" | "Mud" | "Ground" | "Asphalt" | "Salt" | "Ice" | "Glacier" | "Glass" | "ForceField" | "Air" | "Water" | "Cardboard" | "Carpet" | "CeramicTiles" | "ClayRoofTiles" | "RoofShingles" | "Leather" | "Plaster" | "Rubber"), Transparency: number }): ()
			Load()
			WriteEVENT_CreatePuppet(Value1, Value2)
			local Buffer, Size, Instances = SendBuffer, SendCursor, SendInstances
			for _, Player in Players:GetPlayers() do
				Load(PlayersMap[Player])
				local Position = Allocate(Size)
				buffer.copy(SendBuffer, Position, Buffer, 0, Size)
				table.move(Instances, 1, #Instances, #SendInstances + 1, SendInstances)
				PlayersMap[Player] = Save()
			end
		end,
		FireList = function(List: {Player}, Value1: string, Value2: { CFrame: CFrame, Size: Vector3, Material: ("Plastic" | "SmoothPlastic" | "Neon" | "Wood" | "WoodPlanks" | "Marble" | "Slate" | "Concrete" | "Granite" | "Brick" | "Pebble" | "Cobblestone" | "Rock" | "Sandstone" | "Basalt" | "CrackedLava" | "Limestone" | "Pavement" | "CorrodedMetal" | "DiamondPlate" | "Foil" | "Metal" | "Grass" | "LeafyGrass" | "Sand" | "Fabric" | "Snow" | "Mud" | "Ground" | "Asphalt" | "Salt" | "Ice" | "Glacier" | "Glass" | "ForceField" | "Air" | "Water" | "Cardboard" | "Carpet" | "CeramicTiles" | "ClayRoofTiles" | "RoofShingles" | "Leather" | "Plaster" | "Rubber"), Transparency: number }): ()
			Load()
			WriteEVENT_CreatePuppet(Value1, Value2)
			local Buffer, Size, Instances = SendBuffer, SendCursor, SendInstances
			for _, Player in List do
				Load(PlayersMap[Player])
				local Position = Allocate(Size)
				buffer.copy(SendBuffer, Position, Buffer, 0, Size)
				table.move(Instances, 1, #Instances, #SendInstances + 1, SendInstances)
				PlayersMap[Player] = Save()
			end
		end,
		FireExcept = function(Except: Player, Value1: string, Value2: { CFrame: CFrame, Size: Vector3, Material: ("Plastic" | "SmoothPlastic" | "Neon" | "Wood" | "WoodPlanks" | "Marble" | "Slate" | "Concrete" | "Granite" | "Brick" | "Pebble" | "Cobblestone" | "Rock" | "Sandstone" | "Basalt" | "CrackedLava" | "Limestone" | "Pavement" | "CorrodedMetal" | "DiamondPlate" | "Foil" | "Metal" | "Grass" | "LeafyGrass" | "Sand" | "Fabric" | "Snow" | "Mud" | "Ground" | "Asphalt" | "Salt" | "Ice" | "Glacier" | "Glass" | "ForceField" | "Air" | "Water" | "Cardboard" | "Carpet" | "CeramicTiles" | "ClayRoofTiles" | "RoofShingles" | "Leather" | "Plaster" | "Rubber"), Transparency: number }): ()
			Load()
			WriteEVENT_CreatePuppet(Value1, Value2)
			local Buffer, Size, Instances = SendBuffer, SendCursor, SendInstances
			for _, Player in Players:GetPlayers() do
				if Player == Except then
					continue
				end
				Load(PlayersMap[Player])
				local Position = Allocate(Size)
				buffer.copy(SendBuffer, Position, Buffer, 0, Size)
				table.move(Instances, 1, #Instances, #SendInstances + 1, SendInstances)
				PlayersMap[Player] = Save()
			end
		end,
	},
	ReplicatePuppetStates = {
		Fire = function(Player: Player, Value: {[string]: CFrame}): ()
			Load(PlayersMap[Player])
			WriteEVENT_ReplicatePuppetStates(Value)
			PlayersMap[Player] = Save()
		end,
		FireAll = function(Value: {[string]: CFrame}): ()
			Load()
			WriteEVENT_ReplicatePuppetStates(Value)
			local Buffer, Size, Instances = SendBuffer, SendCursor, SendInstances
			for _, Player in Players:GetPlayers() do
				Load(PlayersMap[Player])
				local Position = Allocate(Size)
				buffer.copy(SendBuffer, Position, Buffer, 0, Size)
				table.move(Instances, 1, #Instances, #SendInstances + 1, SendInstances)
				PlayersMap[Player] = Save()
			end
		end,
		FireList = function(List: {Player}, Value: {[string]: CFrame}): ()
			Load()
			WriteEVENT_ReplicatePuppetStates(Value)
			local Buffer, Size, Instances = SendBuffer, SendCursor, SendInstances
			for _, Player in List do
				Load(PlayersMap[Player])
				local Position = Allocate(Size)
				buffer.copy(SendBuffer, Position, Buffer, 0, Size)
				table.move(Instances, 1, #Instances, #SendInstances + 1, SendInstances)
				PlayersMap[Player] = Save()
			end
		end,
		FireExcept = function(Except: Player, Value: {[string]: CFrame}): ()
			Load()
			WriteEVENT_ReplicatePuppetStates(Value)
			local Buffer, Size, Instances = SendBuffer, SendCursor, SendInstances
			for _, Player in Players:GetPlayers() do
				if Player == Except then
					continue
				end
				Load(PlayersMap[Player])
				local Position = Allocate(Size)
				buffer.copy(SendBuffer, Position, Buffer, 0, Size)
				table.move(Instances, 1, #Instances, #SendInstances + 1, SendInstances)
				PlayersMap[Player] = Save()
			end
		end,
	},
})
type BLINK_EVENTS_SYMBOL = typeof(Returns)
return Returns :: BLINK_EVENTS_SYMBOL